function t(t,e,n,s){Object.defineProperty(t,e,{get:n,set:s,enumerable:!0,configurable:!0})}var e={};t(e,"UIRoot",(()=>n)),t(e,"Text",(()=>s)),t(e,"FontSize",(()=>i)),t(e,"FontFamily",(()=>r)),t(e,"Child",(()=>o)),t(e,"Children",(()=>a)),t(e,"Connections",(()=>c)),t(e,"Camera",(()=>h)),t(e,"Alignment",(()=>l)),t(e,"CrossAxisAlignment",(()=>d)),t(e,"Width",(()=>g)),t(e,"Height",(()=>f)),t(e,"Translate",(()=>m)),t(e,"Transform",(()=>w)),t(e,"Zoom",(()=>x)),t(e,"From",(()=>A)),t(e,"To",(()=>y)),t(e,"Color",(()=>v)),t(e,"Padding",(()=>p)),t(e,"Constraints",(()=>R)),t(e,"Size",(()=>E)),t(e,"Offset",(()=>T)),t(e,"Layout",(()=>_)),t(e,"WorldSpace",(()=>F)),t(e,"Vertices",(()=>B)),t(e,"TextureCoordinates",(()=>C)),t(e,"Colors",(()=>b)),t(e,"VertexIndices",(()=>S)),t(e,"CameraIndices",(()=>D)),t(e,"Geometry",(()=>I)),t(e,"OnDrag",(()=>U)),t(e,"OnClick",(()=>M)),t(e,"Pointers",(()=>P)),t(e,"PointerDistance",(()=>L)),t(e,"Dragging",(()=>Y)),t(e,"DraggedEntity",(()=>N));class n{constructor(t){this.entity=t}}class s{constructor(t){this.value=t}}class i{constructor(t){this.value=t}}class r{constructor(t){this.value=t}}class o{constructor(t){this.entity=t}}class a{constructor(t){this.entities=t}}class c{constructor(t){this.entities=t}}class h{constructor(t){this.entity=t}}let l;var u;(u=l||(l={}))[u.START=0]="START",u[u.CENTER=1]="CENTER",u[u.END=2]="END";class d{constructor(t){this.alignment=t}}class g{constructor(t){this.value=t}}class f{constructor(t){this.value=t}}class m{constructor(t,e){this.x=t,this.y=e}}class w{constructor(t){this.matrix=t}}class x{constructor(t,e,n){this.scale=t,this.x=e,this.y=n}}class A{constructor(t){this.entity=t}}class y{constructor(t){this.entity=t}}class v{constructor({h:t,s:e,l:n,a:s}){this.h=t,this.s=e,this.l=n,this.a=s}}class p{constructor(t){this.value=t}}class R{constructor(t,e,n,s){this.minWidth=t,this.maxWidth=e,this.minHeight=n,this.maxHeight=s}}class E{constructor(t,e){this.width=t,this.height=e}}class T{constructor(t,e){this.x=t,this.y=e,this.add=t=>new T(this.x+t.x,this.y+t.y)}}class _{constructor(t){this.impl=t,this.layout=(t,e)=>this.impl(t,e)}}class F{constructor(t,e,n,s){this.x=t,this.y=e,this.width=n,this.height=s}}class B{constructor(t){this.data=t}}class C{constructor(t){this.data=t}}class b{constructor(t){this.data=t}}class S{constructor(t){this.data=t}}class D{constructor(t){this.data=t}}class I{constructor(t){this.impl=t,this.geometry=(t,e,n,s)=>this.impl(t,e,n,s)}}class U{constructor(t){this.callback=t}}class M{constructor(t){this.callback=t}}class P{constructor(t){this.events=t}}class L{constructor(t){this.value=t}}class Y{constructor(t){this.value=t}}class N{constructor(t){this.entity=t}}var W={};t(W,"Vec3",(()=>X)),t(W,"Mat3",(()=>k));class X{constructor(t){this.data=t}}class k{constructor(t){this.data=t,this.matMul=t=>{const e=this.data,n=t.data,s=e[0],i=e[1],r=e[2],o=e[3],a=e[4],c=e[5],h=e[6],l=e[7],u=e[8],d=n[0],g=n[1],f=n[2],m=n[3],w=n[4],x=n[5],A=n[6],y=n[7],v=n[8];return new k([s*d+i*m+r*A,s*g+i*w+r*y,s*f+i*x+r*v,o*d+a*m+c*A,o*g+a*w+c*y,o*f+a*x+c*v,h*d+l*m+u*A,h*g+l*w+u*y,h*f+l*x+u*v])},this.vecMul=t=>{const e=this.data,n=t.data,s=e[0],i=e[1],r=e[2],o=e[3],a=e[4],c=e[5],h=e[6],l=e[7],u=e[8],d=n[0],g=n[1],f=n[2];return new X([s*d+i*g+r*f,o*d+a*g+c*f,h*d+l*g+u*f])},this.inverse=()=>{const t=this.data,e=t[0],n=t[1],s=t[2],i=t[3],r=t[4],o=t[5],a=t[6],c=t[7],h=t[8],l=n*o-s*r,u=e*o-s*i,d=e*r-n*i,g=1/(a*l-c*u+h*d);return new k([g*(r*h-o*c),g*-(n*h-s*c),g*l,g*-(i*h-o*a),g*(e*h-s*a),g*-u,g*(i*c-r*a),g*-(e*c-n*a),g*d])}}static identity=()=>new k([1,0,0,0,1,0,0,0,1]);static projection=(t,e)=>new k([2/t,0,-1,0,-2/e,1,0,0,1]);static translation=(t,e)=>new k([1,0,t,0,1,e,0,0,1]);static rotation=t=>{const e=Math.cos(t),n=Math.sin(t);return new k([e,n,0,-n,e,0,0,0,1])};static scaling=(t,e)=>new k([t,0,0,0,e,0,0,0,1])}var z={};t(z,"ECS",(()=>Ct)),t(z,"Entity",(()=>Bt)),t(z,"Renderer",(()=>V)),t(z,"systems",(()=>H)),t(z,"components",(()=>e)),t(z,"ui",(()=>st)),t(z,"Layers",(()=>K)),t(z,"linear_algebra",(()=>W));var H={};t(H,"render",(()=>$)),t(H,"layout",(()=>j)),t(H,"geometry",(()=>Z)),t(H,"rayCast",(()=>J)),t(H,"init",(()=>nt)),t(H,"pointerDown",(()=>Q)),t(H,"pointerMove",(()=>tt)),t(H,"pointerUp",(()=>et));class q{constructor(t){const e=t.createShader(t.VERTEX_SHADER);t.shaderSource(e,"#version 300 es\n  uniform float u_devicePixelRatio;\n  uniform mat3 u_matrices[10];\n\n  layout(location = 0) in vec2 a_position;\n  layout(location = 1) in vec2 a_textureCoordinates;\n  layout(location = 2) in vec4 a_color;\n  layout(location = 3) in uint a_matrixIndex;\n\n  out vec2 v_textureCoordinates;\n  out vec4 v_color;\n\n  void main() {\n    gl_Position = vec4((u_matrices[a_matrixIndex] * vec3(a_position, 1)).xy, 0, 1);\n    v_textureCoordinates = a_textureCoordinates * u_devicePixelRatio;\n    v_color = a_color;\n  }\n  "),t.compileShader(e);const n=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(n,"#version 300 es\n  precision highp float;\n\n  uniform sampler2D u_texture;\n\n  in vec2 v_textureCoordinates;\n  in vec4 v_color;\n\n  out vec4 fragColor;\n  \n  vec4 hslToRgb(in vec4 hsl) {\n    float h = hsl.x / 360.0;\n    vec3 rgb = clamp(abs(mod(h * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return vec4(hsl.z + hsl.y * (rgb - 0.5) * (1.0 - abs(2.0 * hsl.z - 1.0)), hsl.w);\n  }\n\n  void main() {\n    ivec2 size = textureSize(u_texture, 0);\n    vec2 coordinate = v_textureCoordinates / vec2(float(size.x), float(size.y));\n    fragColor = texture(u_texture, coordinate) * hslToRgb(v_color);\n  }\n  "),t.compileShader(n);const s=t.createProgram();t.attachShader(s,e),t.attachShader(s,n),t.linkProgram(s),t.getProgramParameter(s,t.LINK_STATUS)||(console.log(t.getShaderInfoLog(e)),console.log(t.getShaderInfoLog(n))),t.useProgram(s);const i=t.createVertexArray();t.bindVertexArray(i),this.positionBuffer=t.createBuffer(),t.bindAttribLocation(s,0,"a_position"),t.enableVertexAttribArray(0),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),this.textureCoordinatesBuffer=t.createBuffer(),t.bindAttribLocation(s,1,"a_textureCoordinates"),t.enableVertexAttribArray(1),t.bindBuffer(t.ARRAY_BUFFER,this.textureCoordinatesBuffer),t.vertexAttribPointer(1,2,t.FLOAT,!1,0,0),this.colorBuffer=t.createBuffer(),t.bindAttribLocation(s,2,"a_color"),t.enableVertexAttribArray(2),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.vertexAttribPointer(2,4,t.FLOAT,!1,0,0),this.matrixIndexBuffer=t.createBuffer(),t.bindAttribLocation(s,3,"a_matrixIndex"),t.enableVertexAttribArray(3),t.bindBuffer(t.ARRAY_BUFFER,this.matrixIndexBuffer),t.vertexAttribIPointer(3,1,t.UNSIGNED_BYTE,0,0),this.indexBuffer=t.createBuffer(),this.devicePixelRatioLocation=t.getUniformLocation(s,"u_devicePixelRatio"),this.matricesLocation=t.getUniformLocation(s,"u_matrices")}}class G{constructor(t,e,n,s){this.texture=t,this.metrics=e,this.fontFamily=n,this.fontSize=s,this.metric=t=>this.metrics[t.charCodeAt(0)]}}const O=(t,e,n,s)=>{const i=document.createElement("canvas"),r=i.getContext("2d"),o=Math.sqrt(256),a=(t=>{let e=1;for(;e<t;)e<<=1;return e})(s*o),c=a/o;i.width=a*window.devicePixelRatio,i.height=a*window.devicePixelRatio,i.style.width=`${a}px`,i.style.height=`${a}px`,r.scale(window.devicePixelRatio,window.devicePixelRatio),r.textAlign="left",r.textBaseline="top",r.font=n,r.fillStyle="white";const h=Array.from({length:256},((t,e)=>e)).map((t=>String.fromCharCode(t)));r.clearRect(0,0,r.canvas.width,r.canvas.height);const l=h.map(((t,e)=>{const n=r.measureText(t),i=Math.ceil(n.width),a=s,h=e%o*c,l=Math.floor(e/o)*c;return r.fillText(t,h,l),{x:h,y:l,width:i,height:a}}));return t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,i),t.generateMipmap(t.TEXTURE_2D),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),l};class V{constructor(t,e){const n=document.createElement("canvas");n.style.touchAction="none";const s=n.getContext("webgl2");s.clearColor(0,0,0,1),s.enable(s.BLEND),s.blendFunc(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA),s.depthMask(!1),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),s.activeTexture(s.TEXTURE0),this.gl=s,this.canvas=n,this.program=new q(s),this.fontAtlasses=new Map,this.textures=[],this.devicePixelRatio=window.devicePixelRatio,this.setSize(t,e);const i=s.createTexture();s.bindTexture(s.TEXTURE_2D,i),s.texImage2D(s.TEXTURE_2D,0,s.RGBA,1,1,0,s.RGBA,s.UNSIGNED_BYTE,new Uint8Array([255,255,255,255])),this.textures.push(i)}setSize=(t,e)=>{const{gl:n,canvas:s}=this;s.width=t*window.devicePixelRatio,s.height=e*window.devicePixelRatio,n.uniform2f(this.program.resolutionLocation,s.width,s.height),n.uniform1f(this.program.devicePixelRatioLocation,window.devicePixelRatio),n.viewport(0,0,s.width,s.height),this.width=t,this.height=e,this.devicePixelRatio!=window.devicePixelRatio&&(this.devicePixelRatio=window.devicePixelRatio,this.recreateFontAtlasses())};clear=()=>{const{gl:t}=this;t.clear(t.COLOR_BUFFER_BIT)};setMatrices=t=>{const{gl:e}=this,n=[];for(const e of t)n.push(...e.data);e.uniformMatrix3fv(this.program.matricesLocation,!0,n)};draw=({vertices:t,colors:e,textureCoordinates:n,vertexIndices:s,cameraIndices:i})=>{const{gl:r,program:o}=this;r.bindBuffer(r.ARRAY_BUFFER,o.positionBuffer),r.bufferData(r.ARRAY_BUFFER,new Float32Array(t),r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,o.colorBuffer),r.bufferData(r.ARRAY_BUFFER,new Float32Array(e),r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,o.textureCoordinatesBuffer),r.bufferData(r.ARRAY_BUFFER,new Float32Array(n),r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,o.indexBuffer),r.bufferData(r.ELEMENT_ARRAY_BUFFER,new Uint16Array(s),r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,o.matrixIndexBuffer),r.bufferData(r.ARRAY_BUFFER,new Uint8Array(i),r.STATIC_DRAW),r.drawElements(r.TRIANGLES,s.length,r.UNSIGNED_SHORT,0)};drawLines=({vertices:t,colors:e,textureCoordinates:n,cameraIndices:s})=>{const{gl:i,program:r}=this;i.bindBuffer(i.ARRAY_BUFFER,r.positionBuffer),i.bufferData(i.ARRAY_BUFFER,new Float32Array(t),i.STATIC_DRAW),i.bindBuffer(i.ARRAY_BUFFER,r.colorBuffer),i.bufferData(i.ARRAY_BUFFER,new Float32Array(e),i.STATIC_DRAW),i.bindBuffer(i.ARRAY_BUFFER,r.textureCoordinatesBuffer),i.bufferData(i.ARRAY_BUFFER,new Float32Array(n),i.STATIC_DRAW),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,r.indexBuffer),i.bindBuffer(i.ARRAY_BUFFER,r.matrixIndexBuffer),i.bufferData(i.ARRAY_BUFFER,new Uint8Array(s),i.STATIC_DRAW),i.drawArrays(i.LINES,0,t.length/2)};recreateFontAtlasses=()=>{for(const[t,e]of this.fontAtlasses){const n=this.textures[e.texture],s=O(this.gl,n,t,e.fontSize);e.metrics=s}};fontAtlas=(t,e)=>{const n=`${e}px ${t}`,s=this.fontAtlasses.get(n);if(s)return s;const{gl:i}=this,r=i.createTexture(),o=O(i,r,n,e),a=this.textures.length;this.textures.push(r);const c=new G(a,o,t,e);return this.fontAtlasses.set(n,c),c}}const $=t=>{j(t);const e=Z(t),n=t.get(V),s=k.projection(n.width,n.height);n.setMatrices(e.cameras.map((t=>s.matMul(t.inverse())))),n.clear(),((t,e)=>{const{gl:n}=t;let s=[],i=[],r=[],o=[],a=[],c=-1;for(const h of e.layers)for(const[e,l]of h){e!=c&&(s.length&&(t.draw({vertices:s,colors:i,textureCoordinates:r,vertexIndices:o,cameraIndices:a}),s=[],i=[],r=[],o=[],a=[]),c=e,n.bindTexture(n.TEXTURE_2D,t.textures[e]));for(const t of l){const e=s.length/2;s.push(...t.get(B).data),i.push(...t.get(b).data),r.push(...t.get(C).data);for(const n of t.get(S).data)o.push(e+n);a.push(...t.get(D).data)}}0!=s.length&&t.draw({vertices:s,colors:i,textureCoordinates:r,vertexIndices:o,cameraIndices:a})})(n,e),((t,e)=>{const{gl:n}=t;let s=[],i=[],r=[],o=[];n.bindTexture(n.TEXTURE_2D,t.textures[0]);for(const t of e.lines)s.push(...t.get(B).data),i.push(...t.get(b).data),r.push(...t.get(C).data),o.push(...t.get(D).data);0!=s.length&&t.drawLines({vertices:s,colors:i,textureCoordinates:r,cameraIndices:o})})(n,e),t.set(e)},j=t=>{const{width:e,height:s}=t.get(V),i=t.get(n).entity,r=new R(0,e,0,s);i.get(_).layout(i,r)};class K{constructor(){this.layers=[],this.lines=[],this.cameras=[k.identity()],this.activeCamera=0}pushAndSetActiveCamera=t=>{this.activeCamera=this.cameras.length,this.cameras.push(t)};push=({z:t,texture:e,entity:n})=>{for(let e=this.layers.length;e<t+1;++e)this.layers.push(new Map);const s=this.layers[t],i=s.get(e);i?i.push(n):s.set(e,[n])}}const Z=t=>{const e=new K,s=t.get(n).entity;return s.get(I).geometry(s,new T(0,0),e,0),e};function*J(t,e,n){const[s,i,r]=e.vecMul(n).data;for(const e of t.get(K).layers.reverse())for(const t of e.values())for(const e of t){const{x:t,y:n,width:r,height:o}=e.get(F);s>t&&s<t+r&&i>n&&i<n+o&&(yield e)}}const Q=t=>{document.addEventListener("pointerdown",(e=>{if(1!=t.update(P,(t=>(t.events.push(e),t.events.length))))return;const n=t.get(h).entity.get(w).matrix,s=new X([e.clientX,e.clientY,1]);for(const e of J(t,n,s)){const n=e.get(M);if(n)return n.callback(e),void requestAnimationFrame((()=>$(t)))}t.update(Y,(t=>t.value=!0))}))},tt=t=>{document.addEventListener("pointermove",(e=>{const n=t.get(P).events;n[n.findIndex((t=>t.pointerId==e.pointerId))]=e,t.get(Y).value&&1==n.length?((t,e)=>{const n=t.get(h).entity,s=t.get(N).entity;if(s)return(0,s.get(U).callback)(s,e.movementX,e.movementY),void requestAnimationFrame((()=>$(t)));const i=n.get(w).matrix,r=new X([e.clientX,e.clientY,1]);for(const n of J(t,i,r)){const s=n.get(U);if(s)return t.update(N,(t=>t.entity=n)),s.callback(n,e.movementX,e.movementY),void requestAnimationFrame((()=>$(t)))}n.update(w,(t=>{const n=k.translation(-e.movementX,-e.movementY);t.matrix=t.matrix.matMul(n)})),requestAnimationFrame((()=>$(t)))})(t,e):2==n.length&&((t,e,n)=>{const[s,i]=[e[0].clientX,e[0].clientY],[r,o]=[e[1].clientX,e[1].clientY],a=Math.sqrt(Math.pow(r-s,2)+Math.pow(o-i,2)),c=t.get(L).value;if(c>0){const e=k.translation(n.clientX,n.clientY),s=Math.pow(2,.01*(c-a)),i=k.scaling(s,s),r=k.translation(-n.clientX,-n.clientY),o=e.matMul(i).matMul(r);t.get(h).entity.update(w,(t=>t.matrix=t.matrix.matMul(o)))}t.update(L,(t=>t.value=a)),requestAnimationFrame((()=>$(t)))})(t,n,e)}))},et=t=>{document.addEventListener("pointerup",(e=>{0==t.update(P,(t=>(t.events.splice(t.events.findIndex((t=>t.pointerId==e.pointerId)),1),t.events.length)))&&(t.update(Y,(t=>t.value=!1)),t.update(L,(t=>t.value=0)),t.update(N,(t=>t.entity=null)))}))},nt=t=>{t.set(new P([]),new L(0),new Y(!1),new N(null)),Q(t),tt(t),et(t)};var st={};t(st,"text",(()=>ot)),t(st,"center",(()=>ht)),t(st,"column",(()=>dt)),t(st,"row",(()=>mt)),t(st,"container",(()=>yt)),t(st,"scene",(()=>_t)),t(st,"connection",(()=>Rt));const it=(t,e)=>{const n=((t,e)=>{const n=e.get(s).value,o=e.get(i).value,a=e.get(r).value,c=t.fontAtlas(a,o);let h=new E(0,0);for(const t of n){const e=c.metric(t);h.width+=e.width,h.height=Math.max(e.height,h.height)}return h})(t.ecs.get(V),t);return t.set(e,n,new T(0,0)),n},rt=(t,e,n,o)=>{const{width:a,height:c}=t.get(E),h=e.add(t.get(T)),l=((t,e,n,o)=>{const a=e.get(s).value,c=e.get(i).value,h=e.get(r).value,{h:l,s:u,l:d,a:g}=e.get(v),f=t.fontAtlas(h,c);let m=0,w=0;const x=[],A=[],y=[],p=[];for(const t of a){const e=f.metric(t),s=n.x+m,i=s+e.width,r=n.y,o=r+e.height;x.push(s,r,s,o,i,r,i,o),A.push(e.x,e.y,e.x,e.y+e.height,e.x+e.width,e.y,e.x+e.width,e.y+e.height),y.push(l,u,d,g,l,u,d,g,l,u,d,g,l,u,d,g),p.push(w+0,w+1,w+2,w+1,w+2,w+3),m+=e.width,w+=4}return e.set(new B(x),new C(A),new b(y),new S(p),new D(Array(w).fill(o.activeCamera))),f.texture})(t.ecs.get(V),t,h,n);n.push({z:o,entity:t,texture:l}),t.set(new F(h.x,h.y,a,c))},ot=(t,...e)=>{const[n,o]="string"==typeof e[0]?[{},e[0]]:[e[0],e[1]];return t.entity(new s(o),new i(n.fontSize??24),new r(n.fontFamily??"monospace"),new v(n.color??{h:0,s:1,l:1,a:1}),new _(it),new I(rt))},at=(t,e)=>{const n=t.get(o).entity,s=n.get(_).layout(n,e);n.update(T,(t=>{t.x=e.maxWidth/2-s.width/2,t.y=e.maxHeight/2-s.height/2}));const i=new E(e.maxWidth,e.maxHeight);return t.set(e,i,new T(0,0)),i},ct=(t,e,n,s)=>{const{width:i,height:r}=t.get(E),a=e.add(t.get(T)),c=t.get(o).entity;c.get(I).geometry(c,a,n,s),t.set(new F(a.x,a.y,i,r))},ht=(t,e)=>t.entity(new _(at),new I(ct),new o(e)),lt=(t,e)=>{let n=0,s=0;const i=t.get(a).entities;for(const t of i){const i=t.get(_).layout(t,e);t.update(T,(t=>t.y=s)),s+=i.height,n=Math.max(n,i.width)}switch(t.get(d).alignment){case l.START:break;case l.CENTER:for(const t of i){const e=t.get(E).width;t.update(T,(t=>t.x=n/2-e/2))}break;case l.END:for(const t of i){const e=t.get(E).width;t.update(T,(t=>t.x=n-e))}}const r=new E(n,s);return t.set(e,r,new T(0,0)),r},ut=(t,e,n,s)=>{const{width:i,height:r}=t.get(E),o=e.add(t.get(T));for(const e of t.get(a).entities)e.get(I).geometry(e,o,n,s);t.set(new F(o.x,o.y,i,r))},dt=(t,...e)=>{const[n,s]=e[0]instanceof Array?[{},e[0]]:[e[0],e[1]];return t.entity(new _(lt),new I(ut),new a(s),new d(n.crossAxisAlignment??l.START))},gt=(t,e)=>{let n=0,s=0;const i=t.get(a).entities;for(const t of i){const i=t.get(_).layout(t,e);t.update(T,(t=>t.x=n)),n+=i.width,s=Math.max(s,i.height)}switch(t.get(d).alignment){case l.START:break;case l.CENTER:for(const t of i){const e=t.get(E).height;t.update(T,(t=>t.y=s/2-e/2))}break;case l.END:for(const t of i){const e=t.get(E).height;t.update(T,(t=>t.y=s-e))}}const r=new E(n,s);return t.set(e,r,new T(0,0)),r},ft=(t,e,n,s)=>{const{width:i,height:r}=t.get(E),o=e.add(t.get(T));for(const e of t.get(a).entities)e.get(I).geometry(e,o,n,s);t.set(new F(o.x,o.y,i,r))},mt=(t,...e)=>{const[n,s]=e[0]instanceof Array?[{},e[0]]:[e[0],e[1]];return t.entity(new _(gt),new I(ft),new a(s),new d(n.crossAxisAlignment??l.START))},wt=(t,e,n)=>Math.max(Math.min(t,n),e),xt=(t,e)=>{const n=t.get(p).value,s=t.get(o),{x:i,y:r}=t.get(m),a=new T(i,r);if(s){const i=s.entity.get(_).layout(s.entity,e),r=new E(Math.min(e.maxWidth,i.width+2*n),Math.min(e.maxHeight,i.height+2*n));return s.entity.update(T,(t=>{t.x=n,t.y=n})),t.set(e,r,a),r}const c=new E(wt(t.get(g).value,e.minWidth,e.maxWidth),wt(t.get(f).value,e.minHeight,e.maxHeight));return t.set(e,c,a),c},At=(t,e,n,s)=>{const i=e.add(t.get(T)),{width:r,height:a}=t.get(E),c=i.x,h=c+r,l=i.y,u=l+a,d=t.get(v);if(d){const{h:e,s:i,l:r,a:o}=d;t.set(new B([c,l,c,u,h,l,h,u]),new C([0,0,0,0,0,0,0,0]),new b([e,i,r,o,e,i,r,o,e,i,r,o,e,i,r,o]),new S([0,1,2,1,2,3]),new D(Array(4).fill(n.activeCamera))),n.push({z:s,texture:0,entity:t})}const g=t.get(o);g&&g.entity.get(I).geometry(g.entity,i,n,s+1),t.set(new F(c,l,r,a))},yt=(t,e,n)=>{const s=t.entity(new _(xt),new I(At),new p(e.padding??0),new g(e.width??0),new f(e.height??0),new m(e.x??0,e.y??0));return e.color&&s.set(new v(e.color)),n&&s.set(new o(n)),e.onDrag&&s.set(new U(e.onDrag)),e.onClick&&s.set(new M(e.onClick)),s},vt=(t,e,n)=>{const s=e.x+e.width/2,i=e.y+e.height/2,r=s+50,o=i,a=n.x+n.width/2,c=n.y+n.height/2,h=a-50,l=c,u=[];let d=0,g=0;for(const e of t){const t=e*e,n=t*e,f=1-e,m=f*f,w=m*f,x=3*m*e,A=3*f*t,y=w*s+x*r+A*h+n*a,v=w*i+x*o+A*l+n*c;u.length?u.push(d,g):u.push(y,v),u.push(y,v),d=y,g=v}return u},pt=(t,e)=>{const n=((t,e,n)=>{const s=(e-t)/(n-1);return Array.from({length:n},((e,n)=>t+s*n))})(0,1,20),s=Array(80).fill(0);for(const i of t){const t=i.get(A).entity.get(F),r=i.get(y).entity.get(F),o=vt(n,t,r),{h:a,s:c,l:h,a:l}=i.get(v),u=[];for(let t=0;t<40;++t)u.push(a,c,h,l);i.set(new B(o),new C(s),new b(u),new D(Array(o.length/2).fill(e.activeCamera))),e.lines.push(i)}},Rt=(t,e)=>t.entity(new A(e.from),new y(e.to),new v(e.color??{h:0,s:1,l:1,a:1})),Et=(t,e)=>{for(const n of t.get(a).entities)n.get(_).layout(n,e);const n=new E(e.maxWidth,e.maxHeight);return t.set(e,n,new T(0,0)),n},Tt=(t,e,n,s)=>{const i=t.ecs.get(h).entity.get(w).matrix;n.pushAndSetActiveCamera(i);const{width:r,height:o}=t.get(E),l=e.add(t.get(T));for(const e of t.get(a).entities)e.get(I).geometry(e,l,n,s);pt(t.get(c).entities,n),t.set(new F(l.x,l.y,r,o))},_t=(t,e)=>t.entity(new _(Et),new I(Tt),new a(e.children),new c(e.connections));class Ft{constructor(){this.clear()}get=t=>{const e=this.lookup.get(t.id);return null!=e?this.data[e]:void 0};hasId=t=>this.lookup.has(t);set=(t,e)=>{const n=this.lookup.get(t.id);if(n)return this.data[n]=e,void(this.inverses[n]=t.id);this.lookup.set(t.id,this.data.length),this.data.push(e),this.inverses.push(t.id)};clear=()=>{this.lookup=new Map,this.data=[],this.inverses=[]}}class Bt{constructor(t,e){this.id=t,this.ecs=e,this.set=(...t)=>{for(const e of t){const t=e.constructor;let n=this.ecs.storages.get(t);n||(n=new Ft,this.ecs.storages.set(t,n)),n.set(this,e)}return this},this.get=t=>{const e=this.ecs.storages.get(t);return e?e.get(this):void 0},this.update=(t,e)=>e(this.ecs.storages.get(t).get(this))}}class Ct{constructor(){this.nextEntityId=0,this.storages=new Map,this.resources=new Map}entity=(...t)=>{const e=new Bt(this.nextEntityId,this);return e.set(...t),++this.nextEntityId,e};query=function*(...t){const e=this.storages.get(t[0]);if(!e)return;const n=t.slice(1).map((t=>this.storages.get(t)));for(const t of e.inverses)n.every((e=>e.hasId(t)))&&(yield new Bt(t,this))};set=(...t)=>{for(const e of t){const t=e.constructor;this.resources.set(t,e)}};get=t=>this.resources.get(t);update=(t,e)=>e(this.resources.get(t));unsetAll=t=>{const e=this.storages.get(t);e&&e.clear()}}const{ECS:bt,Renderer:St}=z,{UIRoot:Dt,Alignment:It,Transform:Ut}=z.components,{text:Mt,column:Pt,row:Lt,container:Yt,scene:Nt,connection:Wt}=z.ui,{render:Xt,init:kt}=z.systems,zt=new bt,Ht=new St(window.innerWidth,window.innerHeight);Ht.canvas.style.width="100%",Ht.canvas.style.height="100%";const qt=(t,e,n)=>t.update(m,(t=>{t.x+=e,t.y+=n}));let Gt=null,Ot=null;const Vt=t=>{if(Ot){const e=Wt(zt,{from:t,to:Ot});ee.update(c,(t=>t.entities.push(e))),Ot.update(v,(t=>t.h-=30)),Ot=null,requestAnimationFrame((()=>Xt(zt)))}else{if(Gt==t)return;null!=Gt&&Gt.update(v,(t=>t.h-=30)),Gt=t,t.update(v,(t=>t.h+=30)),requestAnimationFrame((()=>Xt(zt)))}},$t=t=>{if(Gt){const e=Wt(zt,{from:Gt,to:t});ee.update(c,(t=>t.entities.push(e))),Gt.update(v,(t=>t.h-=30)),Gt=null,requestAnimationFrame((()=>Xt(zt)))}else{if(Ot==t)return;null!=Ot&&Ot.update(v,(t=>t.h-=30)),Ot=t,t.update(v,(t=>t.h+=30)),requestAnimationFrame((()=>Xt(zt)))}},jt=(t,e)=>Pt(zt,Array.from({length:t},((t,n)=>Lt(zt,[Yt(zt,{width:18,height:18,color:e,onClick:$t}),Yt(zt,{width:5}),Yt(zt,{padding:2},Mt(zt,{fontSize:18},`in ${n}`))])))),Kt=(t,e)=>Pt(zt,{crossAxisAlignment:It.END},Array.from({length:t},((t,n)=>Lt(zt,[Yt(zt,{padding:2},Mt(zt,{fontSize:18},`out ${n}`)),Yt(zt,{width:5}),Yt(zt,{width:18,height:18,color:e,onClick:Vt})])))),Zt=Yt(zt,{color:{h:110,s:1,l:.3,a:1},padding:10,x:25,y:200,onDrag:qt},Pt(zt,{crossAxisAlignment:It.CENTER},[Yt(zt,{padding:5},Mt(zt,"Source")),Yt(zt,{height:10}),Lt(zt,[jt(3,{h:70,s:1,l:.7,a:1}),Yt(zt,{width:30}),Kt(2,{h:70,s:1,l:.7,a:1})])])),Jt=Yt(zt,{color:{h:210,s:1,l:.3,a:1},padding:10,x:300,y:100,onDrag:qt},Pt(zt,{crossAxisAlignment:It.CENTER},[Yt(zt,{padding:5},Mt(zt,"Transform")),Yt(zt,{height:10}),Lt(zt,[jt(2,{h:170,s:1,l:.7,a:1}),Yt(zt,{width:30}),Kt(4,{h:170,s:1,l:.7,a:1})])])),Qt=Yt(zt,{color:{h:310,s:1,l:.3,a:1},padding:10,x:550,y:250,onDrag:qt},Pt(zt,{crossAxisAlignment:It.CENTER},[Yt(zt,{padding:5},Mt(zt,"Sink")),Yt(zt,{height:10}),Lt(zt,[jt(3,{h:270,s:1,l:.7,a:1}),Yt(zt,{width:30}),Kt(3,{h:270,s:1,l:.7,a:1})])])),te=zt.entity(new Ut(k.identity())),ee=Nt(zt,{children:[Zt,Jt,Qt],connections:[]});zt.set(Ht,new Dt(ee),new h(te)),kt(zt),requestAnimationFrame((()=>Xt(zt))),window.addEventListener("resize",(()=>{Ht.setSize(Ht.canvas.clientWidth,Ht.canvas.clientHeight),requestAnimationFrame((()=>Xt(zt)))})),document.body.appendChild(Ht.canvas),document.addEventListener("touchend",(()=>{Ht.canvas.requestFullscreen()})),document.addEventListener("wheel",(t=>{t.preventDefault(),te.update(Ut,(e=>{const n=k.translation(t.clientX,t.clientY),s=Math.pow(2,.01*t.deltaY),i=k.scaling(s,s),r=k.translation(-t.clientX,-t.clientY),o=n.matMul(i).matMul(r);e.matrix=e.matrix.matMul(o)})),requestAnimationFrame((()=>Xt(zt)))}),{passive:!1});
//# sourceMappingURL=index.b1d8394c.js.map
