import * as Studio from '../src/studio'

test("push entity to layer zero", () => {
    const layers = new Studio.Layers()
    expect(layers.layers).toEqual([])
})

test("push entities to layer zero with same texture", () => {
    const ecs = new Studio.ECS()
    const layers = new Studio.Layers()
    const entity0 = ecs.entity()
    const entity1 = ecs.entity()
    const texture = 0
    layers.push({ z: 0, entity: entity0, texture })
    {
        const map = new Map<WebGLTexture, Studio.Entity[]>()
        map.set(texture, [entity0])
        expect(layers.layers).toEqual([map])
    }
    layers.push({ z: 0, entity: entity1, texture })
    {
        const map = new Map<WebGLTexture, Studio.Entity[]>()
        map.set(texture, [entity0, entity1])
        expect(layers.layers).toEqual([map])
    }
})

test("push entities to layer zero then one", () => {
    const ecs = new Studio.ECS()
    const layers = new Studio.Layers()
    const entity0 = ecs.entity()
    const entity1 = ecs.entity()
    const entity2 = ecs.entity()
    const texture = 0
    layers.push({ z: 0, entity: entity0, texture })
    layers.push({ z: 0, entity: entity1, texture })
    layers.push({ z: 1, entity: entity2, texture })
    const map0 = new Map<WebGLTexture, Studio.Entity[]>()
    map0.set(texture, [entity0, entity1])
    const map1 = new Map<WebGLTexture, Studio.Entity[]>()
    map1.set(texture, [entity2])
    expect(layers.layers).toEqual([map0, map1])
})

test("push and pop camera", () => {
    const layers = new Studio.Layers()
    expect(layers.activeCamera()).toEqual(0)
    const camera1 = new Studio.linear_algebra.Mat3([1, 2, 3, 4, 5, 6, 7, 8, 9])
    const camera2 = new Studio.linear_algebra.Mat3([9, 8, 7, 6, 5, 4, 3, 2, 1])
    expect(layers.pushCamera(camera1)).toEqual(1)
    expect(layers.activeCamera()).toEqual(1)
    expect(layers.cameras[0].data).toEqual(Studio.linear_algebra.Mat3.identity().data)
    expect(layers.cameras[1].data).toEqual(camera1.data)
    expect(layers.cameras[2]).toBeUndefined()
    expect(layers.cameraStack).toEqual([0, 1])
    expect(layers.pushCamera(camera2)).toEqual(2)
    expect(layers.activeCamera()).toEqual(2)
    expect(layers.cameras[0].data).toEqual(Studio.linear_algebra.Mat3.identity().data)
    expect(layers.cameras[1].data).toEqual(camera1.data)
    expect(layers.cameras[2].data).toEqual(camera2.data)
    expect(layers.cameras[3]).toBeUndefined()
    expect(layers.cameraStack).toEqual([0, 1, 2])
    expect(layers.popCamera()).toEqual(2)
    expect(layers.activeCamera()).toEqual(1)
    expect(layers.cameras[0].data).toEqual(Studio.linear_algebra.Mat3.identity().data)
    expect(layers.cameras[1].data).toEqual(camera1.data)
    expect(layers.cameras[2].data).toEqual(camera2.data)
    expect(layers.cameras[3]).toBeUndefined()
    expect(layers.cameraStack).toEqual([0, 1])
})

test("push entities track camera", () => {
    const ecs = new Studio.ECS()
    const layers = new Studio.Layers()
    const camera1 = new Studio.linear_algebra.Mat3([1, 2, 3, 4, 5, 6, 7, 8, 9])
    const camera2 = new Studio.linear_algebra.Mat3([9, 8, 7, 6, 5, 4, 3, 2, 1])
    const entity0 = ecs.entity()
    const entity1 = ecs.entity()
    const entity2 = ecs.entity()
    const entity3 = ecs.entity()
    layers.push({ z: 0, entity: entity0, texture: 0 })
    expect(layers.cameraForEntity.get(entity0)).toEqual(0)
    layers.pushCamera(camera1)
    layers.push({ z: 0, entity: entity1, texture: 0 })
    expect(layers.cameraForEntity.get(entity1)).toEqual(1)
    layers.pushCamera(camera2)
    layers.push({ z: 0, entity: entity2, texture: 0 })
    expect(layers.cameraForEntity.get(entity2)).toEqual(2)
    layers.popCamera()
    layers.push({ z: 0, entity: entity3, texture: 0 })
    expect(layers.cameraForEntity.get(entity3)).toEqual(1)
})